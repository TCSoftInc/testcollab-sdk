/* tslint:disable */
/* eslint-disable */
/**
 * TC API
 * TestCollab is a test management tool that helps development teams carry out testing effectively and avoid failures. # Introduction This is an API documentation for TestCollab 2.   # Authentication TestCollab supports two forms of authentication:   - An <b>API token</b> is required to make API calls. The token can be generated from user\'s profile; to obtain it login to your TestCollab account and go to [\'My Profile Settings\'](https://testcollab.io/my_profile) and switch to API Token tab. Click on \"Generate new API token\", Once the token is generated it can be sent as a query parameter for the API calls made - https://api.testcollab.io/projects?token=<generated-API-token>    - <b>Bearer authentication</b> (also called token authentication) is an HTTP authentication scheme that involves security tokens called bearer tokens. You can generate bearer auth token using [Login](#operation/login) API.     Send this token as the Authorization header while making requests to protected resources:     `Authorization: Bearer <token>`    For making API calls, we recommend using the <b>API token</b> generated from user profile page as it won\'t affect the on-going user session and will be available until it is revoked by the user who generated it.      # Error Handling Error responses   - `Not Found` - Error is sent when requested resource is not available.   - `Unauthorized - invalid token` - Error is sent when API token sent with the request is invalid or revoked. Error contains status code 401        - `Forbidden` - Error is sent when logged in user is not part of the company, project or his role does not allow to complete given action. Response consist of 403 status code and more information is given in error message. 
 *
 * The version of the OpenAPI document: 2.3.1
 * Contact: support@testcollab.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Activity,
  DefaultResponseError,
  DefectsTimeline,
  ForbiddenError,
  ProjectMetrics,
  ReportPayload,
  ReportResult,
  TCError,
  TestCaseFailureDistribution,
  TestCaseLastRunStatus,
  TestCasePassedBySuite,
  TestCasesProneToError,
  TestPlanBurnDownData,
  TimeSpentPerCase,
} from '../models/index';
import {
    ActivityFromJSON,
    ActivityToJSON,
    DefaultResponseErrorFromJSON,
    DefaultResponseErrorToJSON,
    DefectsTimelineFromJSON,
    DefectsTimelineToJSON,
    ForbiddenErrorFromJSON,
    ForbiddenErrorToJSON,
    ProjectMetricsFromJSON,
    ProjectMetricsToJSON,
    ReportPayloadFromJSON,
    ReportPayloadToJSON,
    ReportResultFromJSON,
    ReportResultToJSON,
    TCErrorFromJSON,
    TCErrorToJSON,
    TestCaseFailureDistributionFromJSON,
    TestCaseFailureDistributionToJSON,
    TestCaseLastRunStatusFromJSON,
    TestCaseLastRunStatusToJSON,
    TestCasePassedBySuiteFromJSON,
    TestCasePassedBySuiteToJSON,
    TestCasesProneToErrorFromJSON,
    TestCasesProneToErrorToJSON,
    TestPlanBurnDownDataFromJSON,
    TestPlanBurnDownDataToJSON,
    TimeSpentPerCaseFromJSON,
    TimeSpentPerCaseToJSON,
} from '../models/index';

export interface GetActivitiesRequest {
    company: string;
    user?: number;
    project?: number;
    entity?: string;
    entityId?: number;
    limit?: number;
    start?: number;
    sort?: string;
    filter?: string;
}

export interface GetDefectTimelineReportRequest {
    reportPayload?: ReportPayload;
}

export interface GetDefectsTimelineRequest {
    project: number;
    startDate?: Date;
    endDate?: Date;
}

export interface GetProjectMetricsRequest {
    project: number;
    startDate?: Date;
    endDate?: Date;
}

export interface GetReportDataRequest {
    reportPayload?: ReportPayload;
}

export interface GetTCFailureDistributionRequest {
    project: number;
    startDate?: Date;
    endDate?: Date;
}

export interface GetTestCaseLastRunStatusRequest {
    project: number;
    startDate?: Date;
    endDate?: Date;
}

export interface GetTestCasePassedPercentRequest {
    project: number;
    startDate?: Date;
    endDate?: Date;
}

export interface GetTestCasesProneToErrorsRequest {
    project: number;
    failThreshold?: number;
    startDate?: Date;
    endDate?: Date;
    limit?: number;
    start?: number;
    sort?: string;
    filter?: string;
}

export interface GetTestPlanBurnDownDataRequest {
    project: number;
    testPlan: number;
}

export interface GetTestPlanBurnDownDataOldRequest {
    project: number;
    testPlan: number;
}

export interface GetTimeSpentPerCaseRequest {
    project: number;
    timeSeries?: GetTimeSpentPerCaseTimeSeriesEnum;
    startDate?: Date;
    endDate?: Date;
}

/**
 * ReportsApi - interface
 * 
 * @export
 * @interface ReportsApiInterface
 */
export interface ReportsApiInterface {
    /**
     * Fetches the recent activities for a Project/Test Plan/User
     * @summary Fetch Recent Activities
     * @param {string} company Company ID
     * @param {number} [user] User ID
     * @param {number} [project] Project ID
     * @param {string} [entity] Possible Values - testcase / testplan / suite
     * @param {number} [entityId] Entity ID - testplan / testcase / suite
     * @param {number} [limit] Limit the size of the returned results
     * @param {number} [start] Skip a specific number of entries (for pagination)
     * @param {string} [sort] Sort according to a specific field.
     * @param {string} [filter] Stringified filter object  (https://strapi.io/documentation/developer-docs/latest/development/plugins/graphql.html#filters)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getActivitiesRaw(requestParameters: GetActivitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Activity>>>;

    /**
     * Fetches the recent activities for a Project/Test Plan/User
     * Fetch Recent Activities
     */
    getActivities(requestParameters: GetActivitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Activity>>;

    /**
     * Get defects timeline for report purpose
     * @summary Get defect timeline
     * @param {ReportPayload} [reportPayload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getDefectTimelineReportRaw(requestParameters: GetDefectTimelineReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReportResult>>;

    /**
     * Get defects timeline for report purpose
     * Get defect timeline
     */
    getDefectTimelineReport(requestParameters: GetDefectTimelineReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReportResult>;

    /**
     * Defects timeline data , helps in plotting Defects Opened graph
     * @summary Defects Reported
     * @param {number} project Project Id
     * @param {Date} [startDate] Used when filter is applied
     * @param {Date} [endDate] Used when filter is applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getDefectsTimelineRaw(requestParameters: GetDefectsTimelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DefectsTimeline>>;

    /**
     * Defects timeline data , helps in plotting Defects Opened graph
     * Defects Reported
     */
    getDefectsTimeline(requestParameters: GetDefectsTimelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DefectsTimeline>;

    /**
     * Fetches the project specific metrics
     * @summary Test Metrics
     * @param {number} project Project ID
     * @param {Date} [startDate] Used when filter is applied
     * @param {Date} [endDate] Used when filter is applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getProjectMetricsRaw(requestParameters: GetProjectMetricsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProjectMetrics>>;

    /**
     * Fetches the project specific metrics
     * Test Metrics
     */
    getProjectMetrics(requestParameters: GetProjectMetricsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProjectMetrics>;

    /**
     * Get report data
     * @summary Get timeline or any other report data
     * @param {ReportPayload} [reportPayload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getReportDataRaw(requestParameters: GetReportDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReportResult>>;

    /**
     * Get report data
     * Get timeline or any other report data
     */
    getReportData(requestParameters: GetReportDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReportResult>;

    /**
     * Fetches the data on test case failure distribution based on the threshold selected
     * @summary Test Cases Failure Distribution
     * @param {number} project Project Id
     * @param {Date} [startDate] Used when filter is applied
     * @param {Date} [endDate] Used when filter is applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getTCFailureDistributionRaw(requestParameters: GetTCFailureDistributionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TestCaseFailureDistribution>>;

    /**
     * Fetches the data on test case failure distribution based on the threshold selected
     * Test Cases Failure Distribution
     */
    getTCFailureDistribution(requestParameters: GetTCFailureDistributionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TestCaseFailureDistribution>;

    /**
     * Fetches summary of last run status for test cases within project
     * @summary Test Cases Last Run Status
     * @param {number} project Project Id
     * @param {Date} [startDate] Used when filter is applied
     * @param {Date} [endDate] Used when filter is applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getTestCaseLastRunStatusRaw(requestParameters: GetTestCaseLastRunStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TestCaseLastRunStatus>>;

    /**
     * Fetches summary of last run status for test cases within project
     * Test Cases Last Run Status
     */
    getTestCaseLastRunStatus(requestParameters: GetTestCaseLastRunStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TestCaseLastRunStatus>;

    /**
     * Fetches test cases passed percetage by suites to form the heatmap
     * @summary Test Cases Passed % by Suite
     * @param {number} project Project Id
     * @param {Date} [startDate] Used when filter is applied
     * @param {Date} [endDate] Used when filter is applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getTestCasePassedPercentRaw(requestParameters: GetTestCasePassedPercentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TestCasePassedBySuite>>>;

    /**
     * Fetches test cases passed percetage by suites to form the heatmap
     * Test Cases Passed % by Suite
     */
    getTestCasePassedPercent(requestParameters: GetTestCasePassedPercentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TestCasePassedBySuite>>;

    /**
     * Fetches the data for the top 5 (max) test cases that are prone to errors based on failure threshold selected
     * @summary Cases Prone to Errors
     * @param {number} project Project Id
     * @param {number} [failThreshold] Used when filter on threshold is applied
     * @param {Date} [startDate] Used when filter is applied
     * @param {Date} [endDate] Used when filter is applied
     * @param {number} [limit] Limit the size of the returned results
     * @param {number} [start] Skip a specific number of entries (for pagination)
     * @param {string} [sort] Sort according to a specific field.
     * @param {string} [filter] Stringified filter object  (https://strapi.io/documentation/developer-docs/latest/development/plugins/graphql.html#filters)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getTestCasesProneToErrorsRaw(requestParameters: GetTestCasesProneToErrorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TestCasesProneToError>>;

    /**
     * Fetches the data for the top 5 (max) test cases that are prone to errors based on failure threshold selected
     * Cases Prone to Errors
     */
    getTestCasesProneToErrors(requestParameters: GetTestCasesProneToErrorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TestCasesProneToError>;

    /**
     * Fetches test plan burn down chart data
     * @summary Test Plan burn down chart data
     * @param {number} project Project Id
     * @param {number} testPlan Test Plan Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getTestPlanBurnDownDataRaw(requestParameters: GetTestPlanBurnDownDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReportResult>>;

    /**
     * Fetches test plan burn down chart data
     * Test Plan burn down chart data
     */
    getTestPlanBurnDownData(requestParameters: GetTestPlanBurnDownDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReportResult>;

    /**
     * Fetches test plan burn down chart data
     * @summary Test Plan burn down chart data
     * @param {number} project Project Id
     * @param {number} testPlan Test Plan Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getTestPlanBurnDownDataOldRaw(requestParameters: GetTestPlanBurnDownDataOldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TestPlanBurnDownData>>;

    /**
     * Fetches test plan burn down chart data
     * Test Plan burn down chart data
     */
    getTestPlanBurnDownDataOld(requestParameters: GetTestPlanBurnDownDataOldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TestPlanBurnDownData>;

    /**
     * Time spent on executing each test case
     * @summary Time Spent on Each Case
     * @param {number} project Project Id
     * @param {'sum' | 'average' | 'min' | 'max'} [timeSeries] When filter on \&quot;time series to plot\&quot; is applied
     * @param {Date} [startDate] Used when filter is applied
     * @param {Date} [endDate] Used when filter is applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getTimeSpentPerCaseRaw(requestParameters: GetTimeSpentPerCaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TimeSpentPerCase>>;

    /**
     * Time spent on executing each test case
     * Time Spent on Each Case
     */
    getTimeSpentPerCase(requestParameters: GetTimeSpentPerCaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TimeSpentPerCase>;

}

/**
 * 
 */
export class ReportsApi extends runtime.BaseAPI implements ReportsApiInterface {

    /**
     * Fetches the recent activities for a Project/Test Plan/User
     * Fetch Recent Activities
     */
    async getActivitiesRaw(requestParameters: GetActivitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Activity>>> {
        if (requestParameters['company'] == null) {
            throw new runtime.RequiredError(
                'company',
                'Required parameter "company" was null or undefined when calling getActivities().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['company'] != null) {
            queryParameters['company'] = requestParameters['company'];
        }

        if (requestParameters['user'] != null) {
            queryParameters['user'] = requestParameters['user'];
        }

        if (requestParameters['project'] != null) {
            queryParameters['project'] = requestParameters['project'];
        }

        if (requestParameters['entity'] != null) {
            queryParameters['entity'] = requestParameters['entity'];
        }

        if (requestParameters['entityId'] != null) {
            queryParameters['entity_id'] = requestParameters['entityId'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['_limit'] = requestParameters['limit'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['_start'] = requestParameters['start'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['_sort'] = requestParameters['sort'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['_filter'] = requestParameters['filter'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/activities`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ActivityFromJSON));
    }

    /**
     * Fetches the recent activities for a Project/Test Plan/User
     * Fetch Recent Activities
     */
    async getActivities(requestParameters: GetActivitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Activity>> {
        const response = await this.getActivitiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get defects timeline for report purpose
     * Get defect timeline
     */
    async getDefectTimelineReportRaw(requestParameters: GetDefectTimelineReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReportResult>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/defects/report`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReportPayloadToJSON(requestParameters['reportPayload']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReportResultFromJSON(jsonValue));
    }

    /**
     * Get defects timeline for report purpose
     * Get defect timeline
     */
    async getDefectTimelineReport(requestParameters: GetDefectTimelineReportRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReportResult> {
        const response = await this.getDefectTimelineReportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Defects timeline data , helps in plotting Defects Opened graph
     * Defects Reported
     */
    async getDefectsTimelineRaw(requestParameters: GetDefectsTimelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DefectsTimeline>> {
        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling getDefectsTimeline().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['project'] != null) {
            queryParameters['project'] = requestParameters['project'];
        }

        if (requestParameters['startDate'] != null) {
            queryParameters['start_date'] = requestParameters['startDate'];
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['end_date'] = requestParameters['endDate'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/project/tcm_reporting/tcm_reports/get_data/defectTimeline`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DefectsTimelineFromJSON(jsonValue));
    }

    /**
     * Defects timeline data , helps in plotting Defects Opened graph
     * Defects Reported
     */
    async getDefectsTimeline(requestParameters: GetDefectsTimelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DefectsTimeline> {
        const response = await this.getDefectsTimelineRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches the project specific metrics
     * Test Metrics
     */
    async getProjectMetricsRaw(requestParameters: GetProjectMetricsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProjectMetrics>> {
        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling getProjectMetrics().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['project'] != null) {
            queryParameters['project'] = requestParameters['project'];
        }

        if (requestParameters['startDate'] != null) {
            queryParameters['start_date'] = requestParameters['startDate'];
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['end_date'] = requestParameters['endDate'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/projects/projectMetrics`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectMetricsFromJSON(jsonValue));
    }

    /**
     * Fetches the project specific metrics
     * Test Metrics
     */
    async getProjectMetrics(requestParameters: GetProjectMetricsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProjectMetrics> {
        const response = await this.getProjectMetricsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get report data
     * Get timeline or any other report data
     */
    async getReportDataRaw(requestParameters: GetReportDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReportResult>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/reports`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReportPayloadToJSON(requestParameters['reportPayload']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReportResultFromJSON(jsonValue));
    }

    /**
     * Get report data
     * Get timeline or any other report data
     */
    async getReportData(requestParameters: GetReportDataRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReportResult> {
        const response = await this.getReportDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches the data on test case failure distribution based on the threshold selected
     * Test Cases Failure Distribution
     */
    async getTCFailureDistributionRaw(requestParameters: GetTCFailureDistributionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TestCaseFailureDistribution>> {
        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling getTCFailureDistribution().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['project'] != null) {
            queryParameters['project'] = requestParameters['project'];
        }

        if (requestParameters['startDate'] != null) {
            queryParameters['start_date'] = requestParameters['startDate'];
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['end_date'] = requestParameters['endDate'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/project/tcm_reporting/tcm_reports/get_data/testFailureDistribution`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TestCaseFailureDistributionFromJSON(jsonValue));
    }

    /**
     * Fetches the data on test case failure distribution based on the threshold selected
     * Test Cases Failure Distribution
     */
    async getTCFailureDistribution(requestParameters: GetTCFailureDistributionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TestCaseFailureDistribution> {
        const response = await this.getTCFailureDistributionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches summary of last run status for test cases within project
     * Test Cases Last Run Status
     */
    async getTestCaseLastRunStatusRaw(requestParameters: GetTestCaseLastRunStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TestCaseLastRunStatus>> {
        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling getTestCaseLastRunStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['project'] != null) {
            queryParameters['project'] = requestParameters['project'];
        }

        if (requestParameters['startDate'] != null) {
            queryParameters['start_date'] = requestParameters['startDate'];
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['end_date'] = requestParameters['endDate'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/project/tcm_reporting/tcm_reports/get_data/testCaseLastStatuses`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TestCaseLastRunStatusFromJSON(jsonValue));
    }

    /**
     * Fetches summary of last run status for test cases within project
     * Test Cases Last Run Status
     */
    async getTestCaseLastRunStatus(requestParameters: GetTestCaseLastRunStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TestCaseLastRunStatus> {
        const response = await this.getTestCaseLastRunStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches test cases passed percetage by suites to form the heatmap
     * Test Cases Passed % by Suite
     */
    async getTestCasePassedPercentRaw(requestParameters: GetTestCasePassedPercentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TestCasePassedBySuite>>> {
        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling getTestCasePassedPercent().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['project'] != null) {
            queryParameters['project'] = requestParameters['project'];
        }

        if (requestParameters['startDate'] != null) {
            queryParameters['start_date'] = requestParameters['startDate'];
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['end_date'] = requestParameters['endDate'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/project/tcm_reporting/tcm_reports/get_data/testCasePassedPercentBySuite`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TestCasePassedBySuiteFromJSON));
    }

    /**
     * Fetches test cases passed percetage by suites to form the heatmap
     * Test Cases Passed % by Suite
     */
    async getTestCasePassedPercent(requestParameters: GetTestCasePassedPercentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TestCasePassedBySuite>> {
        const response = await this.getTestCasePassedPercentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches the data for the top 5 (max) test cases that are prone to errors based on failure threshold selected
     * Cases Prone to Errors
     */
    async getTestCasesProneToErrorsRaw(requestParameters: GetTestCasesProneToErrorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TestCasesProneToError>> {
        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling getTestCasesProneToErrors().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['project'] != null) {
            queryParameters['project'] = requestParameters['project'];
        }

        if (requestParameters['failThreshold'] != null) {
            queryParameters['fail_threshold'] = requestParameters['failThreshold'];
        }

        if (requestParameters['startDate'] != null) {
            queryParameters['start_date'] = requestParameters['startDate'];
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['end_date'] = requestParameters['endDate'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['_limit'] = requestParameters['limit'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['_start'] = requestParameters['start'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['_sort'] = requestParameters['sort'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['_filter'] = requestParameters['filter'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/project/tcm_reporting/tcm_reports/get_data/testCaseProneToErrors`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TestCasesProneToErrorFromJSON(jsonValue));
    }

    /**
     * Fetches the data for the top 5 (max) test cases that are prone to errors based on failure threshold selected
     * Cases Prone to Errors
     */
    async getTestCasesProneToErrors(requestParameters: GetTestCasesProneToErrorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TestCasesProneToError> {
        const response = await this.getTestCasesProneToErrorsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches test plan burn down chart data
     * Test Plan burn down chart data
     */
    async getTestPlanBurnDownDataRaw(requestParameters: GetTestPlanBurnDownDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReportResult>> {
        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling getTestPlanBurnDownData().'
            );
        }

        if (requestParameters['testPlan'] == null) {
            throw new runtime.RequiredError(
                'testPlan',
                'Required parameter "testPlan" was null or undefined when calling getTestPlanBurnDownData().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['project'] != null) {
            queryParameters['project'] = requestParameters['project'];
        }

        if (requestParameters['testPlan'] != null) {
            queryParameters['testPlan'] = requestParameters['testPlan'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/reports/testPlanBurnDownData`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReportResultFromJSON(jsonValue));
    }

    /**
     * Fetches test plan burn down chart data
     * Test Plan burn down chart data
     */
    async getTestPlanBurnDownData(requestParameters: GetTestPlanBurnDownDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReportResult> {
        const response = await this.getTestPlanBurnDownDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches test plan burn down chart data
     * Test Plan burn down chart data
     */
    async getTestPlanBurnDownDataOldRaw(requestParameters: GetTestPlanBurnDownDataOldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TestPlanBurnDownData>> {
        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling getTestPlanBurnDownDataOld().'
            );
        }

        if (requestParameters['testPlan'] == null) {
            throw new runtime.RequiredError(
                'testPlan',
                'Required parameter "testPlan" was null or undefined when calling getTestPlanBurnDownDataOld().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['project'] != null) {
            queryParameters['project'] = requestParameters['project'];
        }

        if (requestParameters['testPlan'] != null) {
            queryParameters['testPlan'] = requestParameters['testPlan'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/project/tcm_reporting/tcm_reports/get_data/testPlanBurnDownData`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TestPlanBurnDownDataFromJSON(jsonValue));
    }

    /**
     * Fetches test plan burn down chart data
     * Test Plan burn down chart data
     */
    async getTestPlanBurnDownDataOld(requestParameters: GetTestPlanBurnDownDataOldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TestPlanBurnDownData> {
        const response = await this.getTestPlanBurnDownDataOldRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Time spent on executing each test case
     * Time Spent on Each Case
     */
    async getTimeSpentPerCaseRaw(requestParameters: GetTimeSpentPerCaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TimeSpentPerCase>> {
        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling getTimeSpentPerCase().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['project'] != null) {
            queryParameters['project'] = requestParameters['project'];
        }

        if (requestParameters['timeSeries'] != null) {
            queryParameters['timeSeries'] = requestParameters['timeSeries'];
        }

        if (requestParameters['startDate'] != null) {
            queryParameters['start_date'] = requestParameters['startDate'];
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['end_date'] = requestParameters['endDate'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/project/tcm_reporting/tcm_reports/get_data/timeSpentPerCase`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TimeSpentPerCaseFromJSON(jsonValue));
    }

    /**
     * Time spent on executing each test case
     * Time Spent on Each Case
     */
    async getTimeSpentPerCase(requestParameters: GetTimeSpentPerCaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TimeSpentPerCase> {
        const response = await this.getTimeSpentPerCaseRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetTimeSpentPerCaseTimeSeriesEnum = {
    Sum: 'sum',
    Average: 'average',
    Min: 'min',
    Max: 'max'
} as const;
export type GetTimeSpentPerCaseTimeSeriesEnum = typeof GetTimeSpentPerCaseTimeSeriesEnum[keyof typeof GetTimeSpentPerCaseTimeSeriesEnum];
