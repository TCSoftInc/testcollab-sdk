/* tslint:disable */
/* eslint-disable */
/**
 * TC API
 * TestCollab is a test management tool that helps development teams carry out testing effectively and avoid failures. # Introduction This is an API documentation for TestCollab 2.   # Authentication TestCollab supports two forms of authentication:   - An <b>API token</b> is required to make API calls. The token can be generated from user\'s profile; to obtain it login to your TestCollab account and go to [\'My Profile Settings\'](https://testcollab.io/my_profile) and switch to API Token tab. Click on \"Generate new API token\", Once the token is generated it can be sent as a query parameter for the API calls made - https://api.testcollab.io/projects?token=<generated-API-token>    - <b>Bearer authentication</b> (also called token authentication) is an HTTP authentication scheme that involves security tokens called bearer tokens. You can generate bearer auth token using [Login](#operation/login) API.     Send this token as the Authorization header while making requests to protected resources:     `Authorization: Bearer <token>`    For making API calls, we recommend using the <b>API token</b> generated from user profile page as it won\'t affect the on-going user session and will be available until it is revoked by the user who generated it.      # Error Handling Error responses   - `Not Found` - Error is sent when requested resource is not available.   - `Unauthorized - invalid token` - Error is sent when API token sent with the request is invalid or revoked. Error contains status code 401        - `Forbidden` - Error is sent when logged in user is not part of the company, project or his role does not allow to complete given action. Response consist of 403 status code and more information is given in error message. 
 *
 * The version of the OpenAPI document: 2.3.1
 * Contact: support@testcollab.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Count,
  DefaultResponseError,
  ExecutionComment,
  ExecutionCommentPayload,
  ForbiddenError,
  TCError,
} from '../models/index';
import {
    CountFromJSON,
    CountToJSON,
    DefaultResponseErrorFromJSON,
    DefaultResponseErrorToJSON,
    ExecutionCommentFromJSON,
    ExecutionCommentToJSON,
    ExecutionCommentPayloadFromJSON,
    ExecutionCommentPayloadToJSON,
    ForbiddenErrorFromJSON,
    ForbiddenErrorToJSON,
    TCErrorFromJSON,
    TCErrorToJSON,
} from '../models/index';

export interface AddExecutionCommentRequest {
    executionCommentPayload?: ExecutionCommentPayload;
}

export interface DeleteExecutionCommentRequest {
    id: number;
    project: number;
}

export interface GetExecutionCommentRequest {
    id: number;
    project: number;
}

export interface GetExecutionCommentsRequest {
    executedTestCase: number;
    project: number;
    limit?: number;
    start?: number;
    sort?: string;
    filter?: string;
}

export interface GetExecutionCommentsCountRequest {
    project: number;
    executedTestCase: number;
}

export interface UpdateExecutionCommentRequest {
    id: number;
    executionCommentPayload?: ExecutionCommentPayload;
}

/**
 * ExecutionCommentsApi - interface
 * 
 * @export
 * @interface ExecutionCommentsApiInterface
 */
export interface ExecutionCommentsApiInterface {
    /**
     * Adds a new execution comment
     * @summary Adds a new execution comment
     * @param {ExecutionCommentPayload} [executionCommentPayload] Comment to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionCommentsApiInterface
     */
    addExecutionCommentRaw(requestParameters: AddExecutionCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecutionComment>>;

    /**
     * Adds a new execution comment
     * Adds a new execution comment
     */
    addExecutionComment(requestParameters: AddExecutionCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecutionComment>;

    /**
     * Deletes a specific execution comment
     * @summary Deletes given execution comment
     * @param {number} id Execution Comment ID
     * @param {number} project Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionCommentsApiInterface
     */
    deleteExecutionCommentRaw(requestParameters: DeleteExecutionCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>>;

    /**
     * Deletes a specific execution comment
     * Deletes given execution comment
     */
    deleteExecutionComment(requestParameters: DeleteExecutionCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object>;

    /**
     * Get execution comment
     * @summary Get execution comment
     * @param {number} id Execution Comment ID
     * @param {number} project Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionCommentsApiInterface
     */
    getExecutionCommentRaw(requestParameters: GetExecutionCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecutionComment>>;

    /**
     * Get execution comment
     * Get execution comment
     */
    getExecutionComment(requestParameters: GetExecutionCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecutionComment>;

    /**
     * Get Execution comments
     * @summary Get Execution comments
     * @param {number} executedTestCase Execution ID
     * @param {number} project Project ID
     * @param {number} [limit] Limit the size of the returned results
     * @param {number} [start] Skip a specific number of entries (for pagination)
     * @param {string} [sort] Sort according to a specific field.
     * @param {string} [filter] Stringified filter object  (https://strapi.io/documentation/developer-docs/latest/development/plugins/graphql.html#filters)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionCommentsApiInterface
     */
    getExecutionCommentsRaw(requestParameters: GetExecutionCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ExecutionComment>>>;

    /**
     * Get Execution comments
     * Get Execution comments
     */
    getExecutionComments(requestParameters: GetExecutionCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ExecutionComment>>;

    /**
     * Get execution comments\' count
     * @summary Get count of execution comments
     * @param {number} project Project ID
     * @param {number} executedTestCase Execution ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionCommentsApiInterface
     */
    getExecutionCommentsCountRaw(requestParameters: GetExecutionCommentsCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Count>>;

    /**
     * Get execution comments\' count
     * Get count of execution comments
     */
    getExecutionCommentsCount(requestParameters: GetExecutionCommentsCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Count>;

    /**
     * Execution to update
     * @summary Updates a execution comment
     * @param {number} id Execution Comment ID
     * @param {ExecutionCommentPayload} [executionCommentPayload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionCommentsApiInterface
     */
    updateExecutionCommentRaw(requestParameters: UpdateExecutionCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecutionComment>>;

    /**
     * Execution to update
     * Updates a execution comment
     */
    updateExecutionComment(requestParameters: UpdateExecutionCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecutionComment>;

}

/**
 * 
 */
export class ExecutionCommentsApi extends runtime.BaseAPI implements ExecutionCommentsApiInterface {

    /**
     * Adds a new execution comment
     * Adds a new execution comment
     */
    async addExecutionCommentRaw(requestParameters: AddExecutionCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecutionComment>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/executioncomments`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExecutionCommentPayloadToJSON(requestParameters['executionCommentPayload']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecutionCommentFromJSON(jsonValue));
    }

    /**
     * Adds a new execution comment
     * Adds a new execution comment
     */
    async addExecutionComment(requestParameters: AddExecutionCommentRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecutionComment> {
        const response = await this.addExecutionCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a specific execution comment
     * Deletes given execution comment
     */
    async deleteExecutionCommentRaw(requestParameters: DeleteExecutionCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteExecutionComment().'
            );
        }

        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling deleteExecutionComment().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['project'] != null) {
            queryParameters['project'] = requestParameters['project'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/executioncomments/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Deletes a specific execution comment
     * Deletes given execution comment
     */
    async deleteExecutionComment(requestParameters: DeleteExecutionCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteExecutionCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get execution comment
     * Get execution comment
     */
    async getExecutionCommentRaw(requestParameters: GetExecutionCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecutionComment>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getExecutionComment().'
            );
        }

        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling getExecutionComment().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['project'] != null) {
            queryParameters['project'] = requestParameters['project'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/executioncomments/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecutionCommentFromJSON(jsonValue));
    }

    /**
     * Get execution comment
     * Get execution comment
     */
    async getExecutionComment(requestParameters: GetExecutionCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecutionComment> {
        const response = await this.getExecutionCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Execution comments
     * Get Execution comments
     */
    async getExecutionCommentsRaw(requestParameters: GetExecutionCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ExecutionComment>>> {
        if (requestParameters['executedTestCase'] == null) {
            throw new runtime.RequiredError(
                'executedTestCase',
                'Required parameter "executedTestCase" was null or undefined when calling getExecutionComments().'
            );
        }

        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling getExecutionComments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['executedTestCase'] != null) {
            queryParameters['executed_test_case'] = requestParameters['executedTestCase'];
        }

        if (requestParameters['project'] != null) {
            queryParameters['project'] = requestParameters['project'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['_limit'] = requestParameters['limit'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['_start'] = requestParameters['start'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['_sort'] = requestParameters['sort'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['_filter'] = requestParameters['filter'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/executioncomments`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ExecutionCommentFromJSON));
    }

    /**
     * Get Execution comments
     * Get Execution comments
     */
    async getExecutionComments(requestParameters: GetExecutionCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ExecutionComment>> {
        const response = await this.getExecutionCommentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get execution comments\' count
     * Get count of execution comments
     */
    async getExecutionCommentsCountRaw(requestParameters: GetExecutionCommentsCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Count>> {
        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling getExecutionCommentsCount().'
            );
        }

        if (requestParameters['executedTestCase'] == null) {
            throw new runtime.RequiredError(
                'executedTestCase',
                'Required parameter "executedTestCase" was null or undefined when calling getExecutionCommentsCount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['project'] != null) {
            queryParameters['project'] = requestParameters['project'];
        }

        if (requestParameters['executedTestCase'] != null) {
            queryParameters['executed_test_case'] = requestParameters['executedTestCase'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/executioncomments/count`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CountFromJSON(jsonValue));
    }

    /**
     * Get execution comments\' count
     * Get count of execution comments
     */
    async getExecutionCommentsCount(requestParameters: GetExecutionCommentsCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Count> {
        const response = await this.getExecutionCommentsCountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Execution to update
     * Updates a execution comment
     */
    async updateExecutionCommentRaw(requestParameters: UpdateExecutionCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecutionComment>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateExecutionComment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // bearerAuth authentication
        }


        let urlPath = `/executioncomments/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ExecutionCommentPayloadToJSON(requestParameters['executionCommentPayload']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecutionCommentFromJSON(jsonValue));
    }

    /**
     * Execution to update
     * Updates a execution comment
     */
    async updateExecutionComment(requestParameters: UpdateExecutionCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecutionComment> {
        const response = await this.updateExecutionCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
